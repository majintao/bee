package {{packageName}}

import (
        "gopkg.in/mgo.v2"
        "gopkg.in/mgo.v2/bson"
        "net/http"
        "nonolive/model/cms"
        nonomongo "nonolive/nonoutils/nonomongo_v2"
        . "nonolive/servers/cms-api-server/utils/logs"
        . "nonolive/servers/cms-api-server/websrv"
        "time"
)

// 分页列表查询参数
type {{modelName|upperFirst}}Params struct {
        Page       int      `json:"page"`
        Limit      int      `json:"limit"`
    {% for value in modelSchemas %}{{value.Name|camelString}} {{value.GoType}} `json:"{{value.Name|snakeString|lowerFirst}}"` // {{value.Comment}}
    {% endfor %}
}


type {{modelName|upperFirst}}ListRespBody struct {
        Models    interface{} `json:"models"`
        TotalRows int         `json:"total_rows"`
}
type {{modelName|upperFirst}}Params struct {
        cms.{{modelName|upperFirst}}
        Id string `json:"_id"`
}



func Get{{modelName|upperFirst}}List(ctx *RequestResponseContext, r *http.Request) {
        rpPtr := ctx.ResponseBodyPtr()
        params := {{modelName|upperFirst}}Params{}
        if code, message := CommonCheckAndGetPostBody(&params, r); code != 0 {
                rpPtr.Code = code
                rpPtr.Message = message
                return
        }
        if params.Page == 0 {
                params.Page = 1
        }
        if params.Limit == 0 {
                params.Limit = 20
        }
        skip := (params.Page - 1) * params.Limit
        var result []*cms.{{modelName|upperFirst}}
        var mongo nonomongo.MongoContext
        defer mongo.Close()
        var where = bson.M{}
        {% for value in modelSchemas %}
            if params.{{value.Name|camelString}} != nil {
        {% if value.OrmTag != "" %} where["{{value.Name|camelString|lowerFirst}}"] = params.{{value.Name|camelString}}{% endif %}
            }
    {% endfor %}
        err := mongo.FindAll(new(cms.{{modelName|upperFirst}}), where).Sort("-_id").Skip(skip).Limit(params.Limit).Retry(3).List(&result)
        if err != nil {
                rpPtr.ErrorCodeAndMessage(1, err.Error())
                return
        }
        count, err := mongo.Count(new(cms.{{modelName|upperFirst}}), where)
        if err != nil {
                rpPtr.ErrorCodeAndMessage(2, err.Error())
                return
        }
        body := {{modelName|upperFirst}}RespBody{
                Models:    result,
                TotalRows: count,
        }
        rpPtr.SetBody(body)
}
func Find{{modelName|upperFirst}}(ctx *RequestResponseContext, r *http.Request) {
        rpPtr := ctx.ResponseBodyPtr()
        _id := r.FormValue("_id")
        var result = &cms.{{modelName|upperFirst}}{}
        var mongo nonomongo.MongoContext
        defer mongo.Close()
        if !bson.IsObjectIdHex(_id) {
                rpPtr.ErrorCodeAndMessage(1, "invalid object id")
                return
        }
        var query = bson.M{"_id": bson.ObjectIdHex(_id)}
        err := mongo.FindOne(result, query)
        if err != nil && err != mgo.ErrNotFound {
                MainLogger.Errorf("find {{modelName|upperFirst}} err, _id =%v, err: %v", _id, err.Error())
                rpPtr.ErrorCodeAndMessage(2, "mongo find failed")
                return
        }
        rpPtr.SetBody(result)
}
func AddOrUpdate{{modelName|upperFirst}}(ctx *RequestResponseContext, r *http.Request) {
        rpPtr := ctx.ResponseBodyPtr()
        params := Update{{modelName|upperFirst}}Params{}
        if code, message := CommonCheckAndGetPostBody(&params, r); code != 0 {
                rpPtr.Code = code
                rpPtr.Message = message
                return
        }
        var where = bson.M{}
        if bson.IsObjectIdHex(params.Id) {
                where["_id"] = bson.ObjectIdHex(params.Id)
        } else {
                where["_id"] = bson.NewObjectId()
        }
        var update = bson.M{
                "$set": bson.M{
                   {% for value in modelSchemas %}{% if value.Name!= "" %}"{{value.Name|snakeString}}" : params.{{value.Name|camelString}},{% endif %}
                   {% endfor %}
                   "update_time":  time.Now(),
                },
                "$setOnInsert": bson.M{"create_time": time.Now()},
        }
        var change = mgo.Change{
                Update:    update,
                Upsert:    true,
                ReturnNew: true,
        }
        var mongo nonomongo.MongoContext
        defer mongo.Close()
        var result = &cms.{{modelName|upperFirst}}{}
        _, err := mongo.FindAndModify(result, where, change)
        if err != nil {
                rpPtr.ErrorCodeAndMessage(1, err.Error())
                return
        }

        if bson.IsObjectIdHex(params.Id)  == 0 {
                Delete{{modelName|upperFirst}}(params.Id)
        }
        rpPtr.SetBody("success")
}

func Delete{{modelName|upperFirst}}ById(_id string) bool {
        if !bson.IsObjectIdHex(_id) {
                return false
        }
        var mongo nonomongo.MongoContext
        defer mongo.Close()
        var query = bson.M{"_id": bson.ObjectIdHex(_id)}
        err := mongo.Remove(new(cms.{{modelName|upperFirst}}), query)
        if err != nil {
                MainLogger.Errorf("delete {{modelName|upperFirst}} err, _id =%v, err: %v", _id, err.Error())
                return false
        }
        return true
}

